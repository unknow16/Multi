## JVM
### 类加载子系统
* 负责从文件系统或者网络中加载Class信息，加载的信息存放在一块称为方法区的内存空间
### 方法区
* 存放类信息、常量信息、常量池信息、包括字符串字面量和数字常量
### java堆
* 在jvm启动时建立java堆，它是java程序最主要的内存工作区域，几乎所有的对象事例都存放在此
* 堆空间是所有线程共享的
### 直接内存
java的NIO库允许java程序直接使用内存，从而提高性能，通常直接内存速度会优于java堆，读写频繁的场合可能会考虑使用。
### 栈 
* 每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建时被创建，其中保存局部变量，方法参数，同时java的方法调用、返回值等

## 栈，堆，方法区联系
* 堆解决的是数据存储的问题，即数据怎么放，放在哪
* 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据
* 方法区则是辅助堆栈的快永久区（Perm),解决堆栈信息的产生，是先决条件。



* 栈-----    堆   ------             方法区
* u1引用---- u1实例	--------		
                                 User类及方法实现
* u2引用---- u2实例   -----------｜


## GC
* 分为新生代(def new generation)和老年代（tenured generation）
* 新生代包括
	* eden space  伊甸园区
	* from space(s0) 相等的两个区，用于交换回收，互相拷贝
	* to space(s1)
* 经过多次任然存活的对象会存入老年代

## 堆分配参数
* -XX:+PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志
* -XX:+UseSerialGC 配置串行回收器
* -XX:+PrintGCDetail 可以查看详细信息，包括各个区的情况
* -Xms5m 设置java程序启动时初始堆大小5m
* -Xmx20m 设置java程序能获的最大堆大小

* -Xmx20m -Xms5m -XX:+PrintCommandLineFlags 可以将隐式或显示传给虚拟机的参数输出

> 在实际工作中，我们可以直接将初始的堆大小与最大堆大小设置相等，这样的好处是可以减少程序运行时的垃圾回收次数，从而提高性能

## 
* -Xmn1m   新生代初始化大小，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，新生代大小一般会设置为整个堆空间的1/3到1/4左右
* -XX:SurvivorRatio=2  eden/from=eden/to=2
* eg: eden=512k  from=256k  to=256k 之和等于1M

> 实际应该根据系统特点合理配置，遵循尽可能将对象预留在新生代，减少老年代的GC次数， 除了可以设置新生代的绝对大小（-Xmn），还可以使用（-XX:NewRatio）设置新生代和老生代的比例，-XX:NewRatio=老年代/新生代

##
* -XX:+HeapDumpOnOutOfMemoryError  内存溢出时导出整个堆信息
* -XX:HeapDumpPath=d:/Test03.dump 导出文件的存放路径


## 栈配置
* -Xss1m 指定线程的最大栈空间，该参数决定了函数可调用的最大深度

## 方法区配置
* -XX:PermSize=64M 大小，默认64M
* -XX:MaxPermSize=64M  最大大小

## 直接内存
* -XX:MaxDirectMemorySize
* 如果不设置默认值为最大堆空间，即-Xmx

### Client和Server虚拟机工作模式

## 垃圾收集算法
* 引用计数法，存在循环引用问题
* 标记清除法，内存空间碎片化
* 复制算法，java的新生代from和to空间就是采用这种算法
* 标记压缩法，把存活的对象压缩在一端，java的老生代
* 分代算法，就是根据对象的特点把内存分成N块，而后根据每个内存的特点使用不同的算法，对于新生代回收频率很高，但是每次回收耗时都很短，而老年代回收频率较低，但耗时较长，所以应尽量减少老年代的GC
* 分区算法，主要就是将整个内存分为N个小的独立的空间，每个空间都可以独立使用，这样细粒度的控制一次回收小空间，而不是对整个空间进行GC，从而减少GC的停顿时间

## 垃圾回收时的停顿现象
* 垃圾回收期的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效的执行，大部分情况下，会要求系统进入一个停顿的状态，停顿的目的是终止所有应用线程，只有这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一瞬间的一致性，也有益于更好的标记垃圾对象，因此在垃圾回收时，都会产生应用程序的停顿。

## 对象如何进入老年代
* 一般而言对象首次创建会被放置在新生代的eden区，如果没有GC介入，则对象不会离开eden区，当对象的年龄达到一定的大小，就会进入老年代，对象的年龄是由经历数次GC决定，在新生代每次GC之后没有被回收，则年龄加1，虚拟机提供了一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代
* -XX:MaxTenuringThreshold, 默认15
* 大对象（新生代eden区无法装入时，也会直接进入老年代），JVM里有个参数可以设置对象的大小超过在指定的大小后，直接晋升老年代
* -XX:PretenureSizeThreshold
* 虚拟机对于体积不大的对象 会优先把数据分配到TLAB区域中，因此就失去了在老年代分配的机会 
* -XX:-UseTLAB  （-相当于禁用tlab区域， + 代表启用）

## TLAB
* 全称Thread Local Allocation Buffer 即线程本地分配缓存

## 垃圾收集器
* 串行垃圾回收器
* 并行垃圾回收器
* CMS回收器 并发标记清除（Concurrent Mark Sweep）
* G1回收器 jdk1.7提出的
